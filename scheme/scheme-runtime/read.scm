;;; read.scm -- input/output procedures

;;; Commentary:


;;; Code:

;; INPUT

(define-record-type (<reader-error> <error>)
  (make-read-error message)
  read-error?)

(define (read-error! reason)
  (signal (make-read-error reason)))

(define (optional-input-port port)
  (if (null? port)
      (current-input-port)
      (car port)))

(define (skip-spaces port)
  ;; advances port up to a non space character 
  (let ((c (peek-char port)))
    (cond ((eof-object? c) c)
          ((char-whitespace? c)
           (read-char port) 
           (skip-spaces port))
          ((char=? c #\;) 
           (read-comment port)
           (skip-spaces port))
          (else c))))

(define (symbol-initial? c)
  (or (memq c '(#\! #\$ #\% #\& #\* #\+ #\- #\/ #\: #\< #\= #\> #\? #\^ #\_ #\~))
      (char-alphabetic? c)))

(define (symbol-subsequent? c)
  (or (symbol-initial? c)
      (char-numeric? c)
      (memq c '(#\+ #\- #\. #\@))))


(define (read . port)
  (let ((real-port (optional-input-port port)))
    (let ((c (skip-spaces real-port)))
      (cond ((eof-object? c)     c)
            ((char=? c #\#)      (read-hash real-port))
            ((or (char=? c #\+) (char=? c #\-)) (read-symbol/number real-port))
	    ((char-numeric? c)   (read-number 10 real-port))
	    ((char=? #\" c)      (read-string real-port)) 
	    ((char=? #\( c)      (read-char real-port) (read-list #\) real-port))
            ((char=? #\[ c)      (read-char real-port) (read-list #\] real-port))
	    ((symbol-initial? c) (read-symbol/keyword real-port))
	    ((char=? c #\')      (read-quote real-port))
	    ((char=? c #\`)      (read-backquote real-port))
            ((char=? c #\,)      (read-comma real-port))
            ((char=? c #\.)      (read-dotdotdot real-port))
	    (else 
             (read-char real-port)
             (read-error! (string-append "Unrecognized start of token >"
                                         (make-string 1 c)
                                         "<")))))))

(define (read-symbol/number port)
  (let* ((first (read-char port))
         (next (peek-char port)))
    (if (char-numeric? next)
        (if (char=? first #\+)
            (read-number 10 port)
            (- 0 (read-number 10 port)))
        (if (symbol-subsequent? next)            
            (let* ((sym (read-symbol/keyword port)))
              (string->symbol (string-append (make-string 1 first)
                                             (symbol->string sym))))
            (string->symbol (make-string 1 first))))))

(define (read-comment port)
  (let loop ((ch (read-char port)))
    (if (char=? ch #\newline)
        #t
        (loop (read-char port)))))

(define (read-block-comment end port)
  (let loop ((ch (read-char port)))
    (if (eof-object? ch)
        (read-error! "End of file inside block comment #|")
        (if (char=? ch end)
            (let ((next (read-char port)))
              (if (eof-object? next)
                  (read-error! "End of file inside block comment")
                  (if (char=? next #\#)
                      (read port)
                      (loop (read-char port)))))
            (loop (read-char port))))))

(define (read-dotdotdot port)
  (read-char port)
  (let* ((c2 (peek-char port)))
    (if (char=? c2 #\.)
	(let* ((c2 (read-char port))
	       (c3 (peek-char port)))
	  (if (char=? c3 #\.)
	      (begin (read-char port)
		     (string->symbol "..."))
	      (read-error! "Undefined .. token")))
	(string->symbol "."))))
	
(define (read-quote port)
  (read-char port)
  (let ((next (read port)))
    (list 'quote next)))

(define (read-backquote port)
  (read-char port)
  (let ((next (read port)))
    (list 'quasiquote next)))

(define (read-comma port)
  (read-char port)
  (let ((c (peek-char port)))
    (if (char=? c #\@)
        (begin 
	  (read-char port)
	  (let ((next (read port)))
	    (list 'unquote-splicing next)))
	(let ((next (read port)))
	  (list 'unquote next)))))

(define (read-hash port)
  (read-char port)
  (let ((c (read-char port)))
    (cond ((eof-object? c) (read-error! "End of file reading # syntax"))
	  ((char=? c #\\) (read-character port))
          ((char=? c #\() (read-vector port))
          ((char=? c #\f) #f)
          ((char=? c #\t) #t)
          ((char=? c #\e) (read-number 10 port))
          ((char=? c #\i) (read-number 10 port))
	  ((char=? c #\b) (read-number 2 port))
	  ((char=? c #\x) (read-number 16 port))
	  ((char=? c #\o) (read-number 8 port))
	  ((char=? c #\!) (read-comment port))
	  ((char=? c #\;) (read-commented-exp port))
          ((char=? c #\|) (read-block-comment #\| port))
          ((char=? c #\#) (read-port-attribute port))
	  ((char=? c #\<) (read-here-string-maybe port))
          (else (read-error! "Unknown character for # syntax")))))

(define (read-commented-exp port)
  (let ((comment (read port)))
    (read port)))

(define (read-here-string-maybe port)
  (let ((ch (peek-char port)))
    (cond ((eof-object? ch) (read-error! "End of file reading #< syntax"))
	  ((char=? ch #\<) (read-here-string port))
	  (else (read-error! "Unknown #< syntax")))))

(define (read-here-string port)
  (read-char port)
  (let ((end (read-here-word port)))
    (apply string-append
	   (let ((separator (string #\newline)))
	     (let loop ((line (read-line port)))
	       (cond ((eof-object? line) (read-error! "End of file inside here string"))
		     ((string=? line end) '())
		     (else 
		      (let ((rest (loop (read-line port))))
			(if (null? rest)
			    (list line)
			    (cons line (cons separator rest)))))))))))
  
(define (read-here-word port)
  (list->string
   (let loop ((c (peek-char port)))
     (cond ((eof-object? c) (read-error! "End of file reading here word"))
	   ((char-alphabetic? c)
	    (let ((_ (read-char port)))
	      (cons c (loop (peek-char port)))))
	   ((char=? c #\newline) (let ((_ (read-char port))) '()))
	   ((< (char->integer c) (char->integer #\space))
	    (let ((_ (read-char port))) (loop (peek-char port))))
	   (else (read-error! "Bad character used in here string"))))))

(define (read-port-attribute port)
  (let ((attribute (read-word port)))
    (cond ((string=? attribute "file") #f)
          ((string=? attribute "line") #f)
          ((string=? attribute "column") #f)
          ((string=? attribute "pos") #f)
          (else (read-error! "Unknown attribute in ## syntax")))))

(define (read-word port)
  (list->string
   (let loop ((c (peek-char port)))
     (cond ((eof-object? c) '())
	   ((char-alphabetic? c)
	    (let ((_ (read-char port)))
	      (cons c (loop (peek-char port)))))
	   (else '())))))

(define (read-character port)
  (let ((c (peek-char port)))
    (cond ((eof-object? c) (read-error! "End of file before reading a character constant"))
	  ((char-alphabetic? c)        
	   (let ((s (read-word port)))
	     (cond ((string=? s "newline") (integer->char 10))
		   ((string=? s "space")  (integer->char 32))
		   ((string=? s "tab") (integer->char 9))
		   ((string=? s "vtab") (integer->char 11))
		   ((string=? s "bell") (integer->char 7))
		   ((string=? s "backspace") (integer->char 8))
		   ((string=? s "escape") (integer->char 27))
		   ((string=? s "linefeed") (integer->char 10))
		   ((string=? s "formfeed") (integer->char 12))
		   ((string=? s "return") (integer->char 13))
		   (else
		    (if (= 1 (string-length s))
			(string-ref s 0)
			(read-error! "Unknown character constant"))))))
	  (else (read-char port)))))

(define (read-vector port)
  (list->vector
    (let loop ((c (skip-spaces port)))
      (if (eof-object? c)
          (read-error! "End of file inside vector")
          (if (char=? c #\))
              (begin 
                (read-char port) 
                '())
              (let ((head (read port)))
                (cons head (loop (skip-spaces port)))))))))

(define (read-number base port)
  (let* (($hex "0123456789abcdef")
	 (digit->number (lambda (c) 
			  (let loop ((i 0))
			    (if (< i (string-length $hex))
				(if (char-ci=? (string-ref $hex i) c)
				    i
				    (loop (+ i 1)))
				#f)))))
    (let loop ((c (peek-char port))
	       (n 0))
      (if (eof-object? c)
	  (let ((eof (read-char port)))
	    n)
	  (let ((val (digit->number c)))
	    (if val
		(if (< val base)
		    (let ((c (read-char port)))
		      (loop (peek-char port) (+ (* base n) val)))
		    n)
		(if (char=? c #\.)
		    (read-fractional n port)
		    n)))))))

(define (read-fractional integral port)
  (let ((digit->number (lambda (c) (- (char->integer c) 48))))
    (read-char port)
    (let lp ((c (peek-char port))
	     (frac 0)
	     (base (/ 1 10)))
      
      (cond ((eof-object? port) (+ integral frac))
	    ((char-numeric? c)
	     (let ((n (digit->number c)))
	       (read-char port)
	       (lp (peek-char port)
		   (+ frac (* n base))
		   (/ base 10))))
	    (else (+ integral frac))))))

(define (read-string port)
  (read-char port)
  (list->string
    (let loop ((c (read-char port)))
      (if (eof-object? c)
	  (read-error! "End of file inside string constant")
	  (if (char=? c #\")
	      '()
	      (if (char=? c #\\)
		  (let ((c2 (read-char port)))
		    (cond ((char=? c2 #\n) (cons #\newline (loop (read-char port))))
			  ((char=? c2 #\r) (cons (integer->char 13)
						 (loop (read-char port))))
			  ((char=? c2 #\e) (cons (integer->char 27)
						 (loop (read-char port))))
			  ((char=? c2 #\v) (cons (integer->char 11)
						 (loop (read-char port))))
			  ((char=? c2 #\b) (cons (integer->char 8)
						 (loop (read-char port))))
			  ((char=? c2 #\t) (cons (integer->char 9)
						 (loop (read-char port))))
			  ((char=? c2 #\\) (cons #\\ (loop (read-char port))))
			  ((char=? c2 #\") (cons #\" (loop (read-char port))))
			  (else (cons c2 (loop (read-char port))))))
		  (cons c (loop (read-char port)))))))))

(define $dot (string->symbol "."))

(define (read-list closing-char port)
  (let ((c (skip-spaces port)))
    (if (eof-object? c)
        (read-error! "End of file inside list")
        (if (char=? c closing-char) 
            (begin (read-char port) '())
            (let ((token (read port)))
              (if (eq? token $dot)
                  (begin 
;                   (read-char port)
                    (let ((end (read port))
                          (c (skip-spaces port)))
                      (if (char=? c closing-char)
                          (begin
                            (read-char port) 
                            end)
                          (read-error! "expected closing ) or ]"))))
                  (let ((tail (read-list closing-char port)))
                    (cons token tail))))))))

; (define (read-list port)
;   (let ((c (skip-spaces port)))
;     (cond ((char=? c #\.)
;            (read-char port)
; 	   (let ((end (read port)))
; 	     (let ((c (skip-spaces port)))
; 	       (if (char=? c #\))
; 		   (let ((c (read-char port)))
;                      end)
; 		   (display "read-list: wanted a )")))))
;           ((char=? c #\))
;            (read-char port)
; 	   '())
; 	  (else 
;            (let ((head (read port)))
;              (cons head (read-list port)))))))
         
(define (read-symbol/keyword port)
  (let ((str
	 (list->string
	  (let loop ((c (peek-char port)))
	    (cond ((symbol-subsequent? c)
		   (read-char port)
		   (cons c (loop (peek-char port))))
		  ((memq c '(#\+ #\- #\. #\@))
		   (read-char port)
		   (cons c (loop (peek-char port))))
		  (else '()))))))
    (string->symbol str)))

(define (read-char . port)
  (let ((p (optional-input-port port)))
    (port-read-char p)))

(define (read-line . port)
  (let ((p (optional-input-port port)))
    (port-read-line p)))

(define (peek-char . port)
  (let ((p (optional-input-port port)))
    (port-peek-char p)))

(define $eof 'the-end-of-file-object)

(define (char-ready? . port)
  #t)
;  (%char-ready (input-port-n (optional-input-port port))))

;; OUTPUT

(define (optional-output-port port)
  (if (null? port)
      (current-output-port)
      (car port)))

(define (needs-quoting? obj)
  (or (pair? obj) (vector? obj) (bvec? obj) (symbol? obj)))

(define (write obj . port)
  (let ((real-port (optional-output-port port)))
    ;; (if (needs-quoting? obj)
    ;; 	(port-write-char real-port #\'))
    (write* obj real-port 0)))

(define *write-depth* 100)
(define *write-width* 100)

(define (write* obj port depth)
  (cond ((number? obj)  (write-number obj port))
	((boolean? obj) (write-boolean obj port))
	((symbol? obj)  (write-symbol obj port))
	((bvec? obj)    (write-byte-vector obj port depth))
	((pair? obj)    (write-pair obj port depth))
	((char? obj)    (write-character obj port))
	((string? obj)  (write-string obj port))
	((vector? obj)  (write-vector obj port depth))
	((null? obj)    (port-write-string port "()"))
	((channel? obj) (write-chan obj port))
        ((generic? obj) (write-generic obj port))
	((procedure? obj) (write-procedure obj port))
	((stob? obj)      (write-stob obj port))
	((ref? obj) (write-ref obj port))
	((eof-object? obj) (port-write-string port "#!eof"))
	((unbound-object? obj) (port-write-string port "#!unbound"))
	((unspecific-object? obj) (port-write-string port "#!unspecific"))
	(else (port-write-string port "#!unprintable"))))

(define (write-ref ref port)
  (port-write-string port "#{ref ")
  (write-symbol (ref/name ref) port)
  (port-write-string port " ")
  (write-symbol (ref/module ref) port)
  (port-write-string port "}"))

(define (write-generic gen port)
  (let ((name (generic-name gen)))
    (port-write-string port "#{generic ")
    (port-write-string port (symbol->string name))
    (port-write-string port "}")))

(define (write-procedure proc port)
  (let* ((template (procedure-ref proc 1))
	 (debug (vector-ref template 2)))
    (if debug
	(let ((name (vector-ref debug 0)))
	  (port-write-string port "#{procedure ")
	  (port-write-string port name)
	  (port-write-string port "}"))
	(port-write-string port "#{procedure}"))))

(define (write-stob stob port)
  (write-object stob port))

(define-generic write-object (obj port))

(define-method write-object ((obj <top>) port)
  (port-write-string port "#{")
  (write-symbol (record-type-name (class-of obj)) port)
  (port-write-string port "}"))

(define-method write-object ((obj <<class>>) port)
  (port-write-string port "#{class ")
  (write-symbol (record-type-name obj) port)
  (port-write-string port "}"))

(define (write-chan channel port)
  (port-write-string port "#{channel ")
  (port-write-string port (number->string (channel-number channel)))
  (port-write-string port "}"))

(define (write-character char port)
  (let ((code (char->integer char)))
    (cond ((= code 32)
	   (port-write-string port "#\\space"))
	  ((= code 10)
	   (port-write-string port "#\\newline"))
	  ((= code 8)
	   (port-write-string port "#\\tab"))
	  ((= code 13)
	   (port-write-string port "#\\return"))
	  ((< code 32)
	   (port-write-string port "#\\u")
	   (write-number code port))
	  (else
	   (port-write-string port "#\\")
	   (port-write-char port char)))))

(define (write-number number port)
  (port-write-string port (number->string number)))

(define (write-boolean bool port)
  (port-write-string port (if bool "#t" "#f")))

(define (write-symbol symbol port)
  (port-write-string port (symbol->string symbol)))

(define (write-vector vector port depth)
  (port-write-string port "#(")
  (let loop ((i 0))
    (if (< i (vector-length vector))
	(if (and *write-width* (< i *write-width*))
	    (begin
	      (if (< depth *write-depth*)
		  (write* (vector-ref vector i) port (+ depth 1))
		  (port-write-string port "..."))
	      (if (< (+ i 1) (vector-length vector))
		  (port-write-char port #\space))
	      (loop (+ i 1)))
	    (begin 
	      (port-write-string port "...")
	      (loop (vector-length vector))))))
  (port-write-char port #\)))

(define (write-byte-vector vector port depth)
  (port-write-string port "#[")
  (let loop ((i 0))
    (if (< i (bvec-length vector))
	(if (and *write-width* (< i *write-width*))
	    (begin
	      (if (< depth *write-depth*)
		  (write* (bvec-ref vector i) port (+ depth 1))
		  (port-write-string port "..."))
	      (if (< (+ i 1) (bvec-length vector))
		  (port-write-char port #\space))
	      (loop (+ i 1)))
	    (begin 
	      (port-write-string port "...")
	      (loop (bvec-length vector))))))
  (port-write-char port #\]))

(define (write-pair pair port depth)
  (cond ((and (pair? pair)
	      (eq? (car pair) 'quote)
	      (pair? (cdr pair))
	      (null? (cddr pair)))
	 (port-write-string port "'")
	 (write (cadr pair) port))
	((and (pair? pair)
	      (eq? (car pair) 'unquote)
	      (pair? (cdr pair))
	      (null? (cddr pair)))
	 (port-write-string port ",")
	 (write (cadr pair) port))
	((and (pair? pair)
	      (eq? (car pair) 'unquote-splicing)
	      (pair? (cdr pair))
	      (null? (cddr pair)))
	 (port-write-string port ",@")
	 (write (cadr pair) port))
	(else
	 (port-write-char port #\()
	 (let loop ((p pair)
		    (i 0))
	   (if (not (null? p))
	       (if (pair? p)
		   (if (and *write-width* (< i *write-width*))
		       (begin
			 (if (< depth *write-depth*)
			     (write* (car p) port (+ depth 1))
			     (port-write-string port "..."))
			 (if (not (null? (cdr p)))
			     (port-write-char port #\space))
			 (loop (cdr p) (+ i 1)))
		       (begin 
			 (port-write-string port "...")
			 (loop '() i)))
		   (begin 
		     (port-write-char port #\.) 
		     (port-write-char port #\space)
		     (if (< depth *write-depth*)
			 (write* p port (+ depth 1))
			 (port-write-string port "..."))))))
	 (port-write-char port #\)))))

(define (write-string string port)
  (port-write-char port #\")
  (let loop ((i 0))
    (if (< i (string-length string))
        (let* ((ch (string-ref string i))
	       (code (char->integer ch)))
	  (cond ((= code 34) (port-write-string port "\\\""))
		((>= code 32) (port-write-char port ch))
		((= code 10) (port-write-string port "\\n"))
		((= code 13) (port-write-string port "\\r"))
		((= code 8) (port-write-string port "\\t"))
		(else (port-write-string port "\\")
		      (port-write-string port (number->string code))))
          (loop (+ i 1)))))
  (port-write-char port #\"))

(define (display-vector vec port)
  (display "'#(" port)
  (let loop ((i 0))
    (if (< i (vector-length vec))
	(begin 
	  (display (vector-ref vec i) port)
	  (if (< i (- (vector-length vec) 1))
	      (display " " port))
	  (loop (+ i 1)))))
  (display ")" port))

(define (display-bvec bvec port)
  (display "'#[" port)
  (let loop ((i 0))
    (if (< i (bvec-length bvec))
	(begin 
	  (display (bvec-ref bvec i) port)
	  (if (< i (- (bvec-length bvec) 1))
	      (display " " port))
	  (loop (+ i 1)))))
  (display "]" port))

(define (display-generic gen port)
  (let ((name (generic-name gen)))
    (display "#{generic " port)
    (display name port)
    (display "}" port)))

(define (display-procedure proc port)
  (let* ((template (procedure-ref proc 1))
	 (debug (vector-ref template 2)))
    (if debug
	(let ((name (vector-ref debug 0)))
	  (display "#{procedure " port)
;	  (display #\")
	  (display name port)
;	  (display #\")
	  (display "}" port))
	(display "#{procedure}" port))))

(define (display-stob stob port)
  (write-object stob port))

(define (display-pair pair port)
  (write pair port))

(define (display-ref ref port)
  (port-write-string port "#{ref ")
  (write-symbol (ref/name ref) port)
  (port-write-string port " ")
  (write-symbol (ref/module ref) port)
  (port-write-string port "}"))

(define (display obj . port)
  (let ((port (optional-output-port port)))
    (cond ((string? obj) (port-write-string port obj))
          ((char? obj)   (port-write-char port obj))
          ((number? obj) 
	   (port-write-string port (number->string obj)))
	  ((pair? obj)   (display-pair obj port))
	  ((null? obj)   (port-write-string port "()"))
          ((symbol? obj) 
	   (port-write-string port (symbol->string obj)))
	  ((boolean? obj) 
	   (if obj 
	       (port-write-string port "#t") 
	       (port-write-string port "#f")))
	  ((channel? obj)
	   (display "#{channel " port) 
	   (display (channel-number obj) port)
	   (display "}" port))
	  ((vector? obj)    (display-vector obj port))
	  ((bvec? obj)      (display-bvec obj port))
          ((generic? obj)   (display-generic obj port))
	  ((procedure? obj) (display-procedure obj port))
	  ((stob? obj)      (display-stob obj port))
	  ((ref? obj)       (display-ref obj port))
	  ((eof-object? obj) (port-write-string port "#{end of file object}"))
	  ((unbound-object? obj) (port-write-string port "#{unbound}"))
	  ((unspecific-object? obj) (port-write-string port "#{unspecific}"))
	  (else (port-write-string port "#{unknown object}")))))

(define (newline . port)
  (let ((fd (optional-output-port port)))
    (write-char #\newline fd)))

(define (write-char char . port/opt)
  (let ((port (optional-output-port port/opt)))
    (port-write-char port char)))

(define (load filename)
  (display "'load' function not implemented"))

(define (transcript-on filename)
  (display "'transcript-on' function not implemented"))

(define (transcript-off filename)
  (display "'transcript-off' function not implemented"))

(define $current-input-port$ 
  (make-fluid (make-channel-port "<stdin>" 'input #f (make-channel 0))))


(define (current-input-port) (fluid $current-input-port$))

(define $current-output-port$ 
  (make-fluid (make-channel-port "<stdout>" 'output #f (make-channel 1))))

(define (current-output-port) (fluid $current-output-port$))

(define (initialize-i/o!)
  (set-fluid! $current-input-port$ 
	      (make-channel-port "<stdin>" 'input #f (make-channel 0)))
  (set-fluid! $current-output-port$ 
	      (make-channel-port "<stdout>" 'output #f (make-channel 1))))
